<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yashuangyi.github.io","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="数据结构与算法学习笔记作者：亚双义、一真 邮箱：chenzhiyuan1999@gmail.com 时间：2020-3-27  数据结构基本概念 定义 是一门研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作等等的学科 数据结构——数据元素和数据元素关系的集合  数据的逻辑结构：只抽象反应数据元素的逻辑关系——算法设计  集合 线性结构 树形结构 图状结构   数据的存储结构：">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法学习笔记">
<meta property="og:url" content="https://yashuangyi.github.io/2020/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="亚双义一真の博客">
<meta property="og:description" content="数据结构与算法学习笔记作者：亚双义、一真 邮箱：chenzhiyuan1999@gmail.com 时间：2020-3-27  数据结构基本概念 定义 是一门研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作等等的学科 数据结构——数据元素和数据元素关系的集合  数据的逻辑结构：只抽象反应数据元素的逻辑关系——算法设计  集合 线性结构 树形结构 图状结构   数据的存储结构：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yashuangyi.github.io/2020/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png">
<meta property="article:published_time" content="2020-04-16T10:34:00.000Z">
<meta property="article:modified_time" content="2020-04-16T10:35:22.592Z">
<meta property="article:author" content="yashuangyi">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yashuangyi.github.io/2020/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93.png">

<link rel="canonical" href="https://yashuangyi.github.io/2020/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构与算法学习笔记 | 亚双义一真の博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">亚双义一真の博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">码农的奋斗记录史</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">17</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yashuangyi" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yashuangyi.github.io/2020/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="yashuangyi">
      <meta itemprop="description" content="Be RESTful">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亚双义一真の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-16 18:34:00 / 修改时间：18:35:22" itemprop="dateCreated datePublished" datetime="2020-04-16T18:34:00+08:00">2020-04-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0%E6%9D%82%E7%83%A9/" itemprop="url" rel="index"><span itemprop="name">笔记杂烩</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="数据结构与算法学习笔记"><a href="#数据结构与算法学习笔记" class="headerlink" title="数据结构与算法学习笔记"></a>数据结构与算法学习笔记</h2><p>作者：亚双义、一真</p>
<p>邮箱：<a href="mailto:chenzhiyuan1999@gmail.com">chenzhiyuan1999@gmail.com</a></p>
<p>时间：2020-3-27</p>
<hr>
<h3 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h3><ol>
<li><p>定义</p>
<p>是一门研究<strong>非数值计算</strong>的程序设计问题中计算机的<em>操作对象</em>以及它们之间的<em>关系</em>和<em>操作</em>等等的学科</p>
<p>数据结构——数据元素和数据元素关系的集合</p>
</li>
<li><p>数据的逻辑结构：只抽象反应数据元素的逻辑关系——算法设计</p>
<ul>
<li>集合</li>
<li>线性结构</li>
<li>树形结构</li>
<li>图状结构</li>
</ul>
</li>
<li><p>数据的存储结构：数据的逻辑结构在计算机存储器中的实现——算法实现</p>
<ul>
<li>顺序存储结构</li>
<li>链式存储结构</li>
</ul>
</li>
<li><p>数据的运算：检索、排序、插入、删除、修改等</p>
</li>
<li><p>数据类型：一组性质相同的值的集合，以及定义于这个值集合上的一组操作的总称</p>
<ul>
<li>数据结构是数据类型的抽象</li>
<li>数据类型是数据结构在计算机内部的具体表现</li>
<li>一些最基本数据结构可用数据类型实现：数组、字符串等</li>
<li>另一些常用数据结构不能直接用数据类型表示：栈、线性表、树、图等</li>
</ul>
</li>
<li><p>抽象数据类型ADT：指一个数学模型和定义在该模型上的一组操作的总称</p>
<ul>
<li>优点：信息隐蔽和数据封装，使用与实现相分离</li>
<li>包含：存储结构的定义、基本操作的函数原型说明、基本操作的实现</li>
<li>引用运算符<code>&amp;</code>，是起别名的作用</li>
<li>三种传递：值传递、地址传递、引用传递</li>
</ul>
</li>
</ol>
<hr>
<h3 id="算法基本概念"><a href="#算法基本概念" class="headerlink" title="算法基本概念"></a>算法基本概念</h3><ol>
<li>定义：是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作</li>
<li>特性：有穷性，确定性，可行性，输入，输出</li>
<li>衡量算法优劣的标准：正确性，可读性，健壮性，效率</li>
<li>时间复杂度，空间复杂度</li>
<li>数据结构是算法处理的对象，也是设计算法的基础</li>
</ol>
<hr>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><ol>
<li><p>线性结构：是一个数据的有序集</p>
</li>
<li><p>线性表是n个数据元素的有限序列，是最常用而且是最简单的一种数据结构</p>
</li>
<li><p>基本操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InitList(&amp;L);          <span class="comment">//构造一个空的线性表</span></span><br><span class="line">ListLength(L);		  <span class="comment">//求线性表长度</span></span><br><span class="line">GetElem(L,i,&amp;e);	  <span class="comment">//取第i个元素的值</span></span><br><span class="line">ListInsert(&amp;L,i,e);   <span class="comment">//在第i个位置插入新的数据元素</span></span><br><span class="line">ListDelete(&amp;L,i,&amp;e);  <span class="comment">//删除第i个元素，并返回它的值，L长度减一</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>算法：合并两个线性表LA和LB</p>
<ul>
<li><p>步骤</p>
<ol>
<li>从线性表LB中依次取得每个数据元素</li>
<li>按值在线性表LA中进行查访</li>
<li>若不存在，则插入之</li>
</ol>
</li>
<li><p>时间复杂度：<code>O(listLength(LA)*listLength(LB))</code></p>
</li>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(List &amp;La, List Lb)</span> <span class="comment">/* 算法：合并两个线性表LA和LB */</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">/* 将所有在线性表Lb中但不在La中的数据元素插入到La中 */</span></span><br><span class="line">    La_len=ListLength(La); <span class="comment">/* 求线性表的长度 */</span></span><br><span class="line">    Lb_len=ListLength(Lb);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=Lb_len;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       GetElem(Lb,i,e); <span class="comment">/* 取Lb中第i个数据元素赋给e */</span></span><br><span class="line">       <span class="keyword">if</span>(!LocateElem(La,e,equal)) <span class="comment">/* La中不存在和e相同的元素,则插入之 */</span></span><br><span class="line">      	 ListInsert(La,++La_len,e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>算法：合并两个线性表，并按顺序</p>
<ul>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(List La,List Lb,List &amp;Lc)</span> <span class="comment">/* 算法：合并两个线性表，并按顺序 */</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     InitList(Lc); <span class="comment">/* 创建空表Lc */</span></span><br><span class="line">     La_len=ListLength(La);</span><br><span class="line">     Lb_len=ListLength(Lb);</span><br><span class="line">     <span class="keyword">while</span>(i&lt;=La_len&amp;&amp;j&lt;=Lb_len) <span class="comment">//表La和表Lb均非空 </span></span><br><span class="line">     &#123;</span><br><span class="line">         GetElem(La,i,ai); </span><br><span class="line">         GetElem(Lb,j,bj);</span><br><span class="line">         <span class="keyword">if</span>(ai&lt;=bj)</span><br><span class="line">         &#123;  </span><br><span class="line">             ListInsert(Lc,++k,ai);       </span><br><span class="line">             ++i; </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123; </span><br><span class="line">             ListInsert(Lc,++k,bj);</span><br><span class="line">             ++j; </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(i&lt;=La_len) <span class="comment">/* 表La非空且表Lb空 */</span></span><br><span class="line">     &#123;</span><br><span class="line">      	GetElem(La,i++,ai);</span><br><span class="line">        ListInsert(Lc,++k,ai);   </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(j&lt;=Lb_len) <span class="comment">/* 表Lb非空且表La空 */</span></span><br><span class="line">     &#123;</span><br><span class="line">      	GetElem(Lb,j++,bj);</span><br><span class="line">        ListInsert(Lc,++k,bj);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>线性表的顺序表示：将线性表中的元素一个接一个地存储在一片相邻的存储区域中，这种结构称为“顺序表”</p>
</li>
<li><p>算法：构造空顺序线性表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList &amp;L)</span> <span class="comment">/* 算法：构造空顺序线性表 */</span></span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line">       L.elem=(ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">       <span class="keyword">if</span>(!L.elem)</span><br><span class="line">         <span class="built_in">exit</span>(OVERFLOW); <span class="comment">/* 存储分配失败 */</span></span><br><span class="line">       L.length=<span class="number">0</span>; <span class="comment">/* 空表长度为0 */</span></span><br><span class="line">       L.listsize=LIST_INIT_SIZE; <span class="comment">/* 初始存储容量 */</span></span><br><span class="line">       <span class="keyword">return</span> OK;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法：顺序表的插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,ElemType e)</span> <span class="comment">/* 算法：顺序表的插入 */</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">/* 顺序线性表L已存在1≤i≤ListLength(L)+1 */</span></span><br><span class="line">   <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) <span class="comment">/* i值不合法 */</span></span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line">   <span class="keyword">if</span>(L.length&gt;=L.listsize <span class="comment">/* 当前存储空间已满,增加分配 */</span></span><br><span class="line">   &#123;</span><br><span class="line">  	  newbase=(ElemType*)<span class="built_in">realloc</span>(L.elem,(L.listsizeLIST + INCREMENT)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">      <span class="keyword">if</span>(!newbase)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW); <span class="comment">/* 存储分配失败 */</span></span><br><span class="line">      L.elem=newbase; <span class="comment">/* 新基址 */</span></span><br><span class="line">      L.listsize+=LISTINCREMENT; <span class="comment">/* 增加存储容量 */</span></span><br><span class="line">   &#125;</span><br><span class="line">   q=&amp;(L.elem[i<span class="number">-1</span>]); <span class="comment">/* q为插入位置 */</span></span><br><span class="line">   <span class="keyword">for</span>(p=&amp;(L.elem[L.length<span class="number">-1</span>];p&gt;=q;--p) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/* 插入位置及之后的元素右移 */</span></span><br><span class="line">      *(p+<span class="number">1</span>)=*p;</span><br><span class="line">      *q=e; <span class="comment">/* 插入e */</span></span><br><span class="line">      ++L.length; <span class="comment">/* 表长增1 */</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法：顺序表的删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,ElemType &amp;e)</span> <span class="comment">/* 算法：顺序表的删除 */</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line">   <span class="comment">/* 结果：删除L的第i个数据元素，并用e返回其值，长度减1 */</span></span><br><span class="line">     <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;(*L).length) <span class="comment">/* i值不合法 */</span></span><br><span class="line">     	<span class="keyword">return</span> ERROR;</span><br><span class="line">     p=&amp;(L.elem[i<span class="number">-1</span>]); <span class="comment">/* p为被删除元素的位置 */</span></span><br><span class="line">     e=*p; <span class="comment">/* 被删除元素的值赋给e */</span></span><br><span class="line">     q=L.elem+L.length<span class="number">-1</span>; <span class="comment">/* 表尾元素的位置 */</span></span><br><span class="line">     <span class="keyword">for</span>(++p;p&lt;=q;++p) <span class="comment">/* 被删除元素之后的元素左移 */</span></span><br><span class="line">     &#123;</span><br><span class="line">         *(p<span class="number">-1</span>)=*p;</span><br><span class="line">         --L.length; <span class="comment">/* 表长减1 */</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> OK;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顺序存储结构的优缺点</p>
<ul>
<li>优点<ol>
<li>逻辑相邻，物理相邻</li>
<li>可随机存取任一元素</li>
<li>存储空间使用紧凑</li>
</ol>
</li>
<li>缺点<ol>
<li>插入、删除操作需要移动大量元素</li>
<li>预先分配空间需按最大空间分配，利用不充分</li>
<li>表容量难以扩充</li>
</ol>
</li>
</ul>
</li>
<li><p>线性表的链式表示：将线性表的n个元素所对应的n个结点通过指针链接成的表，称为线性链表：结点包含数据域和指针域</p>
</li>
<li><p>单链表：每个结点只有一个指针域（存放下个结点的位置）</p>
</li>
<li><p>算法：单链表插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i , ElemType e)</span></span>&#123;</span><br><span class="line">    p=L; j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>) &#123;</span><br><span class="line">        p=p-&gt;next; </span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j&gt;i<span class="number">-1</span>)</span><br><span class="line">   	    <span class="keyword">return</span> ERROR;</span><br><span class="line">    s=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> OK;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法：单链表删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i , ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    p=L; j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>) &#123;</span><br><span class="line">        p=p-&gt;next; </span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j&gt;i<span class="number">-1</span>)</span><br><span class="line">   	    <span class="keyword">return</span> ERROR;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    e=q-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环链表：将单链表的形式稍作改变，不让最后一个结点的指针为NULL，而让它指向头结点</p>
</li>
<li><p>双链表：每个结点有两个指针域（分别存放上一个和下一个结点的位置）</p>
</li>
<li><p>算法：双链表的插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInsert_Dul</span><span class="params">(DuLinkList &amp; L,<span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      DuLinkList s;</span><br><span class="line">      s=(DuLinkList )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuNode));</span><br><span class="line">      s-&gt;data=e;</span><br><span class="line">      s-&gt;prior=p-&gt;prior;</span><br><span class="line">      p-&gt;prior-&gt;next=s;</span><br><span class="line">      s-&gt;next=p;</span><br><span class="line">      p-&gt;prior=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法：双链表的删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListInsert_Dul</span><span class="params">(DuLinkList &amp; L,<span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">      p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line">      <span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><ol>
<li><p>栈和队列是两种特殊的线性表，是操作受限的线性表，称限定性DS</p>
</li>
<li><p>栈Stack</p>
<ul>
<li><p>定义：限定仅在表尾进行插入或删除操作的线性表，表尾——栈顶，表头——栈底，不含元素的空表称空栈</p>
</li>
<li><p>特点：先进后出（FILO）或后进先出（LIFO）</p>
</li>
<li><p>算法：返回栈顶元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(S.top = = S.base) </span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">e=*(S.top<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法：进栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(S.top － S.base&gt;= S.StackSize) &#123;</span><br><span class="line">    S.base =(ElemType*) <span class="built_in">realloc</span> (S.base, S.stacksize+STACKINCREAMENT) * <span class="keyword">sizeof</span> (ElemType);</span><br><span class="line">    <span class="keyword">if</span>(!S.base) </span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S.top=S.base+S.stacksize;</span><br><span class="line">    S.stacksize+= STACKINCREAMENT;</span><br><span class="line">&#125;</span><br><span class="line">*S.top++=e;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法：出栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(S.top = = S.base) </span><br><span class="line">    retuen ERROR;</span><br><span class="line">e=*--S.top;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归：函数直接或间接地调用自身叫递归</p>
</li>
</ul>
</li>
<li><p>队列Queue</p>
<ul>
<li>定义：限定只能在表的一端进行插入，在表的另一端进行删除的线性表，允许插入的一端——队尾rear，允许删除的一端——队头front</li>
<li>特点：先进先出（FIFO）</li>
</ul>
</li>
</ol>
<hr>
<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><ol>
<li>或称为字符串，是由零个或多个字符组成的有限序列，一般记为<code>S=‘a1a2...an’</code>(n&gt;=0)，其中S是串名，用单引号括起来的字符序列是串值</li>
<li>特点：串是特殊的线性表，其特殊性主要在于表的每个元素是一个字符，以及由此而要求的一些特殊操作</li>
<li>长度：一个串中包括的字符个数。长度为0的串称为空串</li>
<li>相关概念<ul>
<li>子串：字符串中任意个连续的字符组成的子序列被称为该串的子串，包含子串的串相应地称为主串</li>
<li>位置：子串在主串中的位置是以子串的第一个字符在主串中的字符序号</li>
<li>相等：两个串的长度相等，并且对应位置上的字符都相等</li>
<li>空格串：由一个或多个空格组成的串</li>
</ul>
</li>
<li>串与线性表的区别<ul>
<li>逻辑结构：串的数据对象约束为字符集</li>
<li>操作：线性表的基本操作大多以“单个元素”为操作对象，而串的基本操作通常以“串的整体”作为操作对象</li>
</ul>
</li>
<li>串的模式匹配算法：求子串位置的定位函数</li>
<li>匹配算法的改进：KMP算法（当主串中第i个字符和模式中第j个字符比较不等时，仅需将模式串向右滑动至模式串中的第k个字符与主串中第i个字符对齐）</li>
</ol>
<hr>
<h3 id="数组和广义表"><a href="#数组和广义表" class="headerlink" title="数组和广义表"></a>数组和广义表</h3><ol>
<li>数组可以看出是一种特殊的线性表，即线性表中数据元素本身也是一个线性表</li>
<li>数组的特点<ul>
<li>数组结构固定</li>
<li>数据元素同构</li>
</ul>
</li>
<li>数组运算<ul>
<li>给定一组下标，存取相应的数据元素</li>
<li>给定一组下标，修改数据元素的值</li>
</ul>
</li>
<li>稀疏矩阵<ul>
<li>定义：非零元较零元少，且分布没有一定规律的矩阵</li>
<li>压缩存储原则：只存矩阵的行列维数和每个非零元的行列下标及其值</li>
</ul>
</li>
<li>广义表的定义：即线性表的推广，表中元素既可以是单个元素，也可以是广义表</li>
</ol>
<hr>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ol>
<li>定义：树是n（n&gt;0）个结点的有限集T，其中：<ul>
<li>有且仅有一个特定的结点，称为树的根</li>
<li>当n&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集T1,T2,…Tm，其中每一个集合本身又是一棵树，称为根的子树</li>
</ul>
</li>
<li>特点<ul>
<li>树中至少有一个结点——根</li>
<li>树中各子树是互不相交的集合</li>
</ul>
</li>
<li>基本术语<ul>
<li>结点：表示树中的元素，包括数据项及若干指向其子树的分支</li>
<li>结点的度：结点拥有的子树数</li>
<li>叶子：度为0的结点</li>
<li>孩子：结点子树的根称为该结点的孩子</li>
<li>双亲：孩子结点的上层结点</li>
<li>兄弟：同一双亲的孩子</li>
<li>树的度：一棵树中最大的结点度数</li>
<li>结点的层次：从根结点算起，根为第一层，它的孩子为第二层</li>
<li>深度：树中结点的最大层次数</li>
<li>森林：m（m&gt;=0）棵互不相交的树的集合</li>
</ul>
</li>
<li>二叉树<ul>
<li>定义：是n（n&gt;=0）个结点的有限集，它或为空树（n=0），或由一个根结点和两棵分别称为左子树和右子树的互不相交的二叉树构成</li>
<li>特点<ol>
<li>每个结点至多有二棵子树（即不存在度大于2的结点）</li>
<li>二叉树的子树有左、右之分，且其次序不能任意颠倒</li>
</ol>
</li>
<li>二叉树性质<ol>
<li>在二叉树的第i层上至多有<code>2的i-1次方</code>个结点（i&gt;=1）</li>
<li>深度为k的二叉树至多有<code>2的k次方-1</code>个结点（k&gt;=1）</li>
<li>对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1</li>
</ol>
</li>
</ul>
</li>
<li>满二叉树<ul>
<li>定义：一棵深度为k且有<code>2的k次方-1</code>个结点的二叉树</li>
<li>特点：每一层上的结点数都是最大结点数</li>
</ul>
</li>
<li>完全二叉树<ul>
<li>定义：深度为k，有n个结点的二叉树当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为完全二叉树</li>
<li>特点<ol>
<li>叶子结点只可能在层次最大的两层上出现</li>
<li>对任一结点，若其右分支下子孙的最大层次为l，则其左分支下子孙的最大层次必为l或l+1</li>
</ol>
</li>
<li>性质<ol>
<li>具有n个结点的完全二叉树的深度为log2n(向下取整)+1</li>
<li>如果对一棵有n个结点的完全二叉树的结点按层序编号，则对任一结点i（1&lt;=i&lt;=n），有：<ul>
<li>如果i=1，则结点i是二叉树的根；如果i&gt;1，则其双亲是i/2(向下取整)</li>
<li>如果2i&gt;n，则结点i无左孩子；如果2i&lt;=n，则其左孩子是2i</li>
<li>如果2i+1&gt;n,则结点i无右孩子；如果2i+1&lt;=n，则其右孩子是2i+1</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>二叉树的存储结构<ul>
<li>顺序存储结构<ol>
<li>实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素</li>
<li>特点<ul>
<li>结点间关系蕴含在其存储位置中</li>
<li>浪费空间，适于存满二叉树和完全二叉树</li>
</ul>
</li>
</ol>
</li>
<li>链式存储结构：二叉链表（左子树指针、数据、右子树指针）、三叉链表（左子树指针、数据、右子树指针、父结点指针）</li>
</ul>
</li>
<li>遍历二叉树<ul>
<li>先序遍历：根左右</li>
<li>中序遍历：左根右</li>
<li>后序遍历：左右根</li>
<li>按层次遍历：从上到下、从左到右访问各结点</li>
</ul>
</li>
<li>线索二叉树<ul>
<li>前驱和后继：在二叉树的先序、中序或后序遍历序列中两个相邻的结点互称为前驱和后继</li>
<li>线索：指向前驱或后继结点的指针</li>
<li>线索二叉树：加上线索的二叉链表表示的二叉树</li>
<li>线索化：对二叉树按某种遍历次序使其变为线索二叉树的过程</li>
</ul>
</li>
<li>树和森林</li>
<li>哈夫曼树——带权路径长度最短的树<ul>
<li>定义<ol>
<li>路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径</li>
<li>路径长度：路径上的分支数</li>
<li>树的路径长度：从树根到每一个结点的路径长度之和</li>
<li>树的带权路径长度：树中所有带权结点的路径长度之和</li>
<li>哈夫曼树：构造一棵有n个叶子结点的二叉树，每个叶子有一定权值，则带权路径长度最小的该树为哈夫曼树</li>
</ol>
</li>
<li>哈夫曼算法<ol>
<li>根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树，令起权值为wj</li>
<li>在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和</li>
<li>在森林中删除这两棵树，同时将新得到的二叉树加入森林中</li>
<li>重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树</li>
</ol>
</li>
</ul>
</li>
<li>哈夫曼编码<ul>
<li>思想：根据字符出现频率编码，使电文总长最短</li>
<li>编码：根据字符出现频率构造Huffman树，然后将树中结点引向其左孩子的分支标“0”，引向其右孩子的分支标“1”；每个字符的编码即为从根到每个叶子的路径上得到的0、1序列</li>
<li>译码：从Huffman树根开始，从待译码电文中逐位取码。若编码是“0”，则向左走；若编码是“1”，则向右走，一旦到达叶子结点，则译出一个字符；再重新从根出发，直到电文结束</li>
</ul>
</li>
<li>二叉排序树<ul>
<li>定义：二叉排序树或是一棵空树，或是具有下列性质的二叉树<ol>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ol>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ol>
<li>定义：图G是由两个集合V(G)（顶点的非空有限集）和E(G)（边的有限集合，边是顶点的无序对或有序对）组成的，记为G=(V,E)</li>
<li>有向图：E(G)是有向边（也称弧）的有限集合，弧是顶点的有序对，记为&lt;v,w&gt;，v,w是顶点，v为弧尾，w为弧头</li>
<li>无向图：E(G)是边的有限集合，边是顶点的无序对，记为（v,w）或（w,v)，并且（v,w)=(w,v)</li>
<li>相关概念<ul>
<li>有向完全图：n个顶点的有向图最大边数是<code>n(n-1)</code></li>
<li>无向完全图：n个顶点的无向图最大边数是<code>n(n-1)/2</code></li>
<li>权：与图的边或弧相关的数</li>
<li>网：带权的图</li>
<li>子图</li>
<li>顶点的度<ol>
<li>无向图中，顶点的度为与每个顶点相连的边数</li>
<li>有向图中，顶点的度分为入度和出度<ul>
<li>入度：以该顶点为头的弧数目</li>
<li>出度：以该顶点为尾的弧数目</li>
</ul>
</li>
</ol>
</li>
<li>路径</li>
<li>路径长度</li>
<li>回路</li>
<li>简单路径：序列中顶点不重复出现的路径</li>
<li>简单回路：除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路</li>
<li>连通</li>
<li>连通图：无向图中任意两个顶点都是连通的</li>
<li>连通分量：非连通图的每一个连通部分</li>
<li>强连通图：有向图中，如果对每一对Vi,Vj属于V, Vi!=Vj,从Vi到Vj和从Vj到Vi都存在路径</li>
<li>生成树：是一个极小的连通子图，包含图中所有顶点，只有足以构成一棵树n-1条边</li>
</ul>
</li>
<li>图的存储结构<ul>
<li>多重链表</li>
<li>数组表示法<ol>
<li>邻接矩阵：表示顶点间相联关系的矩阵</li>
<li>邻接表：为图中每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点Vi的边</li>
<li>有向图的十字链表表示法</li>
</ol>
</li>
</ul>
</li>
<li>图的遍历<ul>
<li>深度优先遍历DFS</li>
<li>广度优先遍历BFS</li>
</ul>
</li>
<li>图的连通性问题：生成树<ul>
<li>定义：所有顶点均由边连接在一起，但不存在回路的图</li>
<li>深度优先生成树和广度优先生成树</li>
<li>生成森林：非连通图每个连通分量的生成树一起组成的非连通图</li>
<li>构造最小生成树方法（要掌握其原理）<ol>
<li>普里姆(Prim)算法</li>
<li>克鲁斯卡尔(Kruskal)算法</li>
</ol>
</li>
</ul>
</li>
<li>拓扑排序</li>
</ol>
<hr>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ol>
<li><p>静态查找</p>
<ul>
<li>顺序查找：从表的一端开始逐个进行记录的关键字和给定值的比较</li>
<li>有序表的查找——折半查找：每次将待查记录所在区间缩小一半</li>
<li>索引顺序表的查找——分块查找：将表分成几块，块内无序，块间有序；先确定待查记录所在块，再在块内查找</li>
</ul>
</li>
<li><p>动态查找</p>
<ul>
<li>二叉排序树的查找、插入和删除</li>
<li>平衡二叉排序树</li>
</ul>
</li>
<li><p>平衡二叉树</p>
<ul>
<li>定义：又称AVL树。它或者是一棵空树，或者是具有下列性质的二叉树</li>
<li>性质<ol>
<li>它的左右子树均为平衡二叉树，且左右子树的深度之差的绝对值不超过1</li>
<li>定义二叉树上结点的平衡因子BF(Balance Factor)为该结点的左子树的深度减去右子树的深度，在平衡二叉树上所有结点平衡因子只可能为-1, 0, 1</li>
<li>对于平衡二叉树来说，它的深度和logN是同数量级的</li>
<li>因此我们希望任何初始序列构成的二叉排序树都是AVL树</li>
</ol>
</li>
</ul>
</li>
<li><p>B-树——用于文件索引</p>
<ul>
<li>性质<ol>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</li>
<li>数中每个节点至多有m棵子树</li>
<li>除根之外的所有分支结点至少有m/2（向下取整）棵子树</li>
<li>若根结点不是叶子结点，则至少有两棵子树</li>
<li>所有叶子结点都在同一层上，并且不带任何信息。实际上这些结点不存在</li>
<li>关键码（详见百度）</li>
</ol>
</li>
</ul>
</li>
<li><p>B+树：B-树的变形</p>
</li>
<li><p>哈希查找</p>
<ul>
<li>基本思想：在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，不经过比较，一次存取就能得到所查元素的查找方法</li>
<li>定义<ol>
<li>哈希函数：在记录的关键字与记录的存储地址之间建立的一种对应关系</li>
<li>哈希表：应用哈希函数和处理冲突的方法，将一组关键字确定在表中的地址，并将记录放入此地址</li>
<li>哈希查找：又叫散列查找，利用哈希函数进行查找的过程</li>
</ol>
</li>
<li>哈希函数的构造方法<ol>
<li>直接定址法</li>
<li>数字分析法</li>
<li>平方取中法</li>
<li>折叠法</li>
<li>除留余数法</li>
<li>随机数法</li>
</ol>
</li>
<li>处理冲突的方法<ol>
<li>开放定址法<ul>
<li>线性探测再散列</li>
<li>二次探测再散列</li>
<li>伪随机探测再散列</li>
</ul>
</li>
<li>再哈希法</li>
<li>链地址法</li>
</ol>
</li>
</ul>
<hr>
<h3 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h3><ol>
<li><p>定义：将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列</p>
</li>
<li><p>分类</p>
<ul>
<li>按待排序记录所在位置<ol>
<li>内部排序：待排序记录存放在内存</li>
<li>外部排序：排序过程中需对外存进行访问的排序</li>
</ol>
</li>
<li>按排序依据原则<ol>
<li>插入排序：直接插入排序、折半插入排序、希尔排序</li>
<li>交换排序：冒泡排序、快速排序</li>
<li>选择排序：简单选择排序、堆排序</li>
<li>归并排序：2-路归并排序</li>
<li>基数排序</li>
</ol>
</li>
<li>按排序所需工作量<ol>
<li>简单的排序方法：T(n)=O(n²)</li>
<li>先进的排序方法：T(n)=O(nlogn)</li>
<li>基数排序：T(n)=O(d.n)</li>
</ol>
</li>
</ul>
</li>
<li><p>插入排序</p>
<ul>
<li>过程：整个排序过程为n-1趟插入，即先将序列中第1个记录看成是一个有序子序列，然后从第2个记录开始，逐个进行插入，直至整个序列有序</li>
<li>时间复杂度：T(n)=O(n²)</li>
<li>空间复杂度：S(n)=O(1)</li>
<li>稳定排序</li>
</ul>
</li>
<li><p>折半插入排序</p>
<ul>
<li>过程：用折半查找方法确定插入位置的排序</li>
<li>时间复杂度：T(n)=O(n²)</li>
<li>空间复杂度：S(n)=O(1)</li>
</ul>
</li>
<li><p>2-路插入排序</p>
</li>
<li><p>表插入排序</p>
</li>
<li><p>希尔排序（缩小增量法）</p>
<ul>
<li>过程：先取一个正整数d1，把所有相隔d1的记录放一组，组内进行直接插入排序；然后取d2，重复上述分组和排序操作；直至di=1，即所有记录放进一个组中排序为止</li>
<li>不稳定排序</li>
</ul>
</li>
<li><p>冒泡排序</p>
<ul>
<li>时间复杂度：T(n)=O(n²)</li>
<li>空间复杂度：S(n)=O(1)</li>
<li>稳定排序</li>
</ul>
</li>
<li><p>快速排序</p>
<ul>
<li>基本思想：通过一趟排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序</li>
<li>时间复杂度：T(n)=O(n²)</li>
<li>空间复杂度：S(n)=O(log2n)~O(n)</li>
</ul>
</li>
<li><p>选择排序</p>
<ul>
<li>基本思想：每一趟在(n-i+1)(i=1,2,…,n-1)个记录中选择关键字最小的 记录作为有序序列中的第i个记录</li>
<li>时间复杂度：T(n)=O(n²)</li>
<li>空间复杂度：S(n)=O(1)</li>
</ul>
</li>
<li><p>树形选择排序（锦标赛排序）</p>
</li>
<li><p>堆排序</p>
<ul>
<li>过程：将无序序列建成一个堆，得到关键字最小（或最大）的记录；输出堆顶的最小（大）值后，使剩余的n-1个元素重又建成一个堆，则可得到n个元素的次小值；重复执行，得到一个有序序列</li>
<li>时间复杂度：T(n)=O(nlogn)</li>
<li>空间复杂度：S(n)=O(1)</li>
</ul>
</li>
<li><p>归并排序</p>
<ul>
<li>基本思想：将两个或两个以上的有序表组合成一个新的有序表</li>
<li>时间复杂度：T(n)=O(nlogn)</li>
<li>空间复杂度：S(n)=O(n)</li>
</ul>
</li>
<li><p>基数排序</p>
</li>
<li><p>总结</p>
<img src="/2020/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/排序总结.png">

<p>选择排序不稳定</p>
</li>
</ol>
</li>
</ol>

    </div>

    
    
    

		<div>
		  
			<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

		  
		</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/07/%E9%9A%8F%E7%AC%94-2020-4-7/" rel="prev" title="[随笔]2020-4-7">
      <i class="fa fa-chevron-left"></i> [随笔]2020-4-7
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/25/%E6%90%AD%E5%BB%BAGithub-Pages-Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" rel="next" title="搭建Github Pages+Hexo个人博客">
      搭建Github Pages+Hexo个人博客 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构与算法学习笔记"><span class="nav-number">1.</span> <span class="nav-text">数据结构与算法学习笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构基本概念"><span class="nav-number">1.1.</span> <span class="nav-text">数据结构基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法基本概念"><span class="nav-number">1.2.</span> <span class="nav-text">算法基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线性表"><span class="nav-number">1.3.</span> <span class="nav-text">线性表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈和队列"><span class="nav-number">1.4.</span> <span class="nav-text">栈和队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串"><span class="nav-number">1.5.</span> <span class="nav-text">串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组和广义表"><span class="nav-number">1.6.</span> <span class="nav-text">数组和广义表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树"><span class="nav-number">1.7.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图"><span class="nav-number">1.8.</span> <span class="nav-text">图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找"><span class="nav-number">1.9.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部排序"><span class="nav-number">1.10.</span> <span class="nav-text">内部排序</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
	  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=33316436&auto=0&height=66"></iframe>
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yashuangyi"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">yashuangyi</p>
  <div class="site-description" itemprop="description">Be RESTful</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yashuangyi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yashuangyi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">亚双义、一真</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

